<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <style>

    </style>
</head>

<body>
    <div id='wrapper'>
        <div id="chart"></div>
    </div>
    <script>
        var morph = function() {



            var canvasDim = {
                width: 600,
                height: 900
            }
            var margin = {
                top: -20,
                right: 5,
                bottom: 5,
                left: 5
            }
            var width = canvasDim.width - margin.left - margin.right
            var height = canvasDim.height - margin.top - margin.bottom
            var radius = canvasDim.width * 0.4

            var circleG, pathG, circle, path
            var clicked = 1
            var nodeRadius = 10
            var modal = d3.select("#chart")

            ///////////////////////////////////////////////////////////////////////////
            ////////////////////////////////// MORPH //////////////////////////////////
            ///////////////////////////////////////////////////////////////////////////

            return {
                clear: function() {
                    modal.select("svg").remove()
                },
                run: function() {

                    //////////////////// Set up and initiate containers ///////////////////////
                    var svg = modal.append("svg")
                        .attr("width", width + margin.left + margin.right)
                        .attr("height", height + margin.top + margin.bottom)
                        .append("g")
                        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

                    pathG = svg.append("g")
                        .attr("class", "pathG")

                    circleG = svg.append("g")
                        .attr("class", "circleG")

                    var data = createData()
                    Graph1(data.nodes, data.links) // initial render of layout 1

                    //     .on("click", function(e) {
                    //         data = createData()
                    //         Graph1(data.nodes, data.links)
                    //     })

                }
            }

            function randomHexColor() {
                //随机生成十六进制颜色 
                var hex = Math.floor(Math.random() * 16777216).toString(16);
                //生成ffffff以内16进制数 
                while (hex.length < 6) {
                    //while循环判断hex位数，少于6位前面加0凑够6位
                    hex = '0' + hex;
                }
                return '#' + hex; //返回‘#'开头16进制颜色
            }

            ///////////////////////////////////////////////////////////////////////////
            /////////////////////// Generate random data /////////////////////////////
            ///////////////////////////////////////////////////////////////////////////

            function createData() {

                //数据
                var nodes = [ //节点集
                    {
                        name: "Dc"
                    }, {
                        name: "M2c"
                    }, {
                        name: "T_cell"
                    }, {
                        name: "Glial cells"
                    }, {
                        name: "Plasmacytoid"
                    }, {
                        name: "Glial "
                    }
                ];
                var links = [ //边集
                    {
                        source: 0,
                        target: 1,
                        force: 2
                    },

                    {
                        source: 1,
                        target: 0,
                        force: 2
                    },
                ];

                const colors = [];
                nodes = nodes.map(function(d, i) {
                    const color = randomHexColor();
                    colors.push(color)
                    return {
                        id: d.name,
                        color
                    }
                })

                console.log(nodes);
                console.log(links);

                return {
                    nodes: nodes,
                    links: links
                }
            }

            function handleCenterPoint(targetX, targetY, sourceX, sourceY, scale) {
                const x = (scale * Math.abs(sourceY - targetY)) / 2 + (sourceX + targetX) / 2;
                const y = (scale * Math.abs(sourceX - targetX)) / 2 + (sourceY + targetY) / 2;
                return {
                    centerX: x,
                    centerY: y
                }
            }

            ///////////////////////////////////////////////////////////////////////////
            //////////////////// Update node and link positions ///////////////////////
            ///////////////////////////////////////////////////////////////////////////

            function update(nodes, links) {

                circle = circleG.selectAll('circle').data(nodes, d => d.id)

                circle.exit().remove()

                entered_circle = circle
                    .enter().append('circle')
                    .attr('r', nodeRadius)
                    .attr('stroke-width', 2)
                    .attr('stroke', function(d) {
                        return d.color
                    })
                    .attr('fill', function(d) {
                        return d.color
                    })
                    .attr('cx', function(d) {
                        return d.x
                    })
                    .attr('cy', function(d) {
                        return d.y
                    })

                circle.append("text")
                    .attr("x", -16)
                    .attr("y", "0.31em")
                    .text(d => d.id)
                    .clone(true).lower()
                    .attr("fill", "none")
                    .attr("font-size", 10)
                    .attr("stroke", "white")
                    .attr("stroke-width", 3);

                circle = circle.merge(entered_circle)

                circle.transition().duration(1000)
                    .attr('cx', function(d) {
                        return d.x
                    })
                    .attr('cy', function(d) {
                        return d.y
                    })
                    .attr('id', function(d) {
                        return "node-" + d.id.toString() + "-"
                    })

                path = pathG.selectAll('path').data(links)

                path.exit().remove()

                entered_path = path
                    .enter().append('path')
                    .attr('stroke-linecap', 'round')
                    .attr('fill', 'transparent')
                    .attr('stroke', function(d) {
                        return d.source.color;
                    })
                    .attr('stroke-width', function(d) {
                        return d.force + 'px'
                    })

                path = path.merge(entered_path)

                // .attr("d", function(d) {
                //     var dx = d.target.x - d.source.x,
                //         dy = d.target.y - d.source.y,
                //         dr = Math.sqrt(dx * dx + dy * dy);

                //     return "M" +
                //         d.source.x + "," +
                //         d.source.y + "L" +
                //         d.target.x + "," +
                //         d.target.y
                // })
                .attr("d", function(d) {
                        var dx = d.target.x - d.source.x,
                            dy = d.target.y - d.source.y;
                        // xddr = Math.floor(dr / 2);
                        // yddr = Math.floor(xddr / 7)
                        //     centerX = Math.floor(d.source.x + d.target.x) / 2 + d.source.x / 2;
                        // centerY = Math.floor(d.source.y + d.target.y) / 2 - d.source.y / 2;
                        var centerX, centerY;
                        // if (d.target.x - d.source.x > 0) {
                        //     centerX = Math.floor(d.source.x + d.target.x) / 2 + d.source.x / 2;
                        //     centerY = Math.floor(d.source.y + d.target.y) / 2 - d.source.y / 2;
                        // } else {
                        //     centerX = Math.floor(d.source.x + d.target.x) / 2 - d.source.x / 2;
                        //     centerY = Math.floor(d.source.y + d.target.y) / 2 + d.source.y / 2;
                        // }
                        const data = handleCenterPoint(d.target.x, d.target.y, d.source.x, d.source.y, 0.2);
                        console.log(data);
                        if (d.target.x - d.source.x > 0) {
                            centerX = data.centerX + 20;
                            centerY = data.centerY - 20;
                        } else {
                            centerX = data.centerX - 20;
                            centerY = data.centerY + 20;
                        }


                        // return `M ${d.source.x}, ${d.source.y} Q${centerX}, ${centerY} ${d.target.x}, ${d.target.y}`
                        return `M ${d.target.x}, ${d.target.y} Q${centerX}, ${centerY} ${d.source.x}, ${d.source.y}`
                    })
                    .attr('stroke-width', '2px')
                    .attr('fill', 'transparent')
                    .attr('stroke', function(d) {
                        return d.source.color
                    })

            }


            ///////////////////////////////////////////////////////////////////////////
            ///////////////////////////// Render Layout 1 /////////////////////////////
            ///////////////////////////////////////////////////////////////////////////

            function Graph1(nodes, links) {

                nodes.forEach((d, i) => {
                    var radian = (2 * Math.PI) / (nodes.length) * i - (Math.PI / 2);
                    d.fx = radius * Math.cos(radian) + (width / 2)
                    d.fy = radius * Math.sin(radian) + (height / 2)

                })

                var simulation1 = d3.forceSimulation(nodes)
                    .force("link", d3.forceLink(links))
                simulation1.tick()

                update(nodes, links)

                clicked = 1

            }

            function getRandomInt(min, max) {
                min = Math.ceil(min);
                max = Math.floor(max);
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

        }()
    </script>
    <script>
        morph.run()
    </script>
</body>

</html>